参照yudao-cloud-mini中的service在goctl中生成的代码里编写逻辑


# 06 编写逻辑：实现核心业务功能

本阶段的目标是参照 YUDAO-Cloud-Mini 的业务逻辑流程，在 `goctl` 依据 API 文件生成的代码骨架中，实现 `system` 模块的核心业务逻辑。我们将以 **用户登录** 和 **用户分页查询** 两个功能为例进行详细展开。

## 核心开发策略：参照与转化

| Go-Zero 组件 | 对应 YUDAO 概念 | 作用 | 实现参考 |
| :--- | :--- | :--- | :--- |
| `*.api` 文件 | Controller (Java) | 定义接口的输入、输出和路由。 | 已完成 (步骤 03) |
| `*.handler.go` | Controller 的路由映射层 | 接收请求，调用 Logic 层。 | 仅少量上下文传递，无需大改。 |
| **`*.logic.go`** | **Service 层 (Java)** | **实现核心业务逻辑、事务处理、权限校验。** | **主要参照 YUDAO Service** |
| `model/*` | Mapper/Repository | 数据库操作层。 | 参照 `zero-admin` 的 Model 封装 |

**前提条件：** 确保您已经完成了 **04 从数据库生成 Model** 这一步，拥有 `system_user_model.go` 等数据库操作代码。

-----

## 示例一：用户登录逻辑 (`LoginLogic.go`)

用户登录是系统的起点，对应我们在 `system.api` 中定义的 `/auth/login` 接口。

### 1\. 逻辑流程（参照 YUDAO 认证服务）

| 步骤 | 逻辑描述 | 涉及组件 | YUDAO 参照点 |
| :--- | :--- | :--- | :--- |
| 1 | **参数校验** | `LoginLogic.go` | 检查 `Username` 和 `Password` 是否为空。 |
| 2 | **查询用户** | `system_user_model` | 根据 `Username` 查询数据库中的用户记录。 |
| 3 | **密码校验** | `LoginLogic.go` | 使用 bcrypt 或类似的加密库，校验用户输入的密码是否与数据库中存储的加密密码匹配。 |
| 4 | **状态校验** | `LoginLogic.go` | 检查用户是否被禁用（例如 `status` 字段）。 |
| 5 | **生成 Token** | `LoginLogic.go` | 如果校验通过，根据用户 ID 和角色信息，生成 JWT 访问令牌 (`accessToken`) 和刷新令牌 (`refreshToken`)。 |
| 6 | **返回结果** | `LoginLogic.go` | 封装 `LoginResp` 结构体，返回令牌和过期时间。 |

### 2\. `LoginLogic.go` 核心代码思路 (Go-Zero 惯例)

```go
// service/system/api/internal/logic/loginLogic.go

func (l *LoginLogic) Login(req *types.LoginReq) (resp *types.LoginResp, err error) {
    // 1. 参数校验（Go-Zero已自动处理基础校验）
    // 2. 查询用户
    user, err := l.svcCtx.UserModel.FindByUsername(l.ctx, req.Username)
    if err != nil {
        // 如果用户不存在或数据库错误，返回登录失败
        return nil, xerr.NewErrMsg("用户名或密码不正确") 
    }

    // 3. 密码校验 (使用 Golang bcrypt)
    // 参照 zero-admin 的工具类，校验明文密码和哈希密码
    if !tool.ValidatePassword(req.Password, user.Password) {
        return nil, xerr.NewErrMsg("用户名或密码不正确")
    }

    // 4. 状态校验
    if user.Status != 0 {
        return nil, xerr.NewErrMsg("用户已被禁用")
    }

    // 5. 生成 Token
    // 引用我们在配置文件中定义的 JWT Secret Key
    now := time.Now().Unix()
    accessExpire := l.svcCtx.Config.Auth.AccessExpire
    
    // 封装 JWT Payload，通常只包含 UserId 和 RoleIds
    token, err := tool.GenToken(now, accessExpire, user.Id, user.RoleIds)
    if err != nil {
        return nil, xerr.NewErrMsg("Token生成失败")
    }

    // 6. 返回结果
    return &types.LoginResp{
        BaseResp: types.BaseResp{Code: 0, Msg: "登录成功"},
        Data: struct {
            AccessToken  string `json:"accessToken"`
            RefreshToken string `json:"refreshToken"`
            ExpiresTime  int64  `json:"expiresTime"`
        }{
            AccessToken: token,
            ExpiresTime: now + accessExpire,
            // RefreshToken 逻辑可后续完善
        },
    }, nil
}
```

-----

## 示例二：用户分页查询逻辑 (`GetUserPageLogic.go`)

该功能对应 `system/user.api` 中定义的 `GET /system/user/page` 接口。

### 1\. 逻辑流程（参照 YUDAO 用户管理服务）

| 步骤 | 逻辑描述 | 涉及组件 | YUDAO 参照点 |
| :--- | :--- | :--- | :--- |
| 1 | **参数处理** | `GetUserPageLogic.go` | 获取 `pageNo` 和 `pageSize`，计算分页偏移量 `offset`。 |
| 2 | **查询总数** | `system_user_model` | 根据筛选条件（`Username` / `Nickname`）查询符合条件的总用户数。 |
| 3 | **查询列表** | `system_user_model` | 根据筛选条件、`offset` 和 `pageSize` 查询分页后的用户列表数据。 |
| 4 | **数据转换** | `GetUserPageLogic.go` | 将 Model 层返回的数据库结构体 (`model.SystemUser`) 转换为 API 要求的响应结构体 (`types.UserResp`)。 |
| 5 | **返回结果** | `GetUserPageLogic.go` | 封装 `UserPageResp`，返回总数和列表。 |

### 2\. `GetUserPageLogic.go` 核心代码思路 (Go-Zero 惯例)

```go
// service/system/api/internal/logic/getUserPageLogic.go

func (l *GetUserPageLogic) GetUserPage(req *types.UserPageReq) (resp *types.UserPageResp, err error) {
    // 1. 参数处理
    offset := (req.PageNo - 1) * req.PageSize
    limit := req.PageSize

    // 2. 查询总数
    total, err := l.svcCtx.UserModel.FindCount(l.ctx, req.Username, req.Nickname)
    if err != nil {
        return nil, xerr.NewErrMsg("查询总数失败")
    }

    // 3. 查询列表
    users, err := l.svcCtx.UserModel.FindPage(l.ctx, offset, limit, req.Username, req.Nickname)
    if err != nil {
        return nil, xerr.NewErrMsg("查询列表失败")
    }

    // 4. 数据转换 (关键步骤：将数据库结构转换为 API 结构)
    var list []types.UserResp
    for _, user := range users {
        list = append(list, types.UserResp{
            Id:           user.Id,
            Username:     user.Username,
            Nickname:     user.Nickname,
            Email:        user.Email.String, 
            PhoneNumber:  user.PhoneNumber.String, 
            Status:       int32(user.Status),
            CreateTime:   user.CreateTime.Format("2006-01-02 15:04:05"),
        })
    }
    
    // 5. 返回结果
    return &types.UserPageResp{
        BaseResp: types.BaseResp{Code: 0, Msg: "查询成功"},
        Data: struct {
            Total int64 `json:"total"`
            List  []types.UserResp `json:"list"`
        }{
            Total: total,
            List:  list,
        },
    }, nil
}
```

-----

## Go-Zero / Zero-Admin 最佳实践总结

在编写 Logic 层的过程中，我们应遵循以下 Go-Zero/Zero-Admin 惯例：

1.  **错误处理（`xerr`）：** 避免直接返回 Go 的原生 `error`，而是使用统一的错误封装（例如 `xerr.NewErrMsg` 或自定义错误码），便于 API 层进行统一拦截和响应。
2.  **上下文依赖（`svcCtx`）：** 所有外部依赖（数据库 Model、配置 `Config`、日志 `Logger`）都应该通过 `l.svcCtx` 获取，而不是直接在 Logic 文件中硬编码或全局变量。
3.  **Model 分离：** Logic 文件只负责业务逻辑，所有的数据库交互（CRUD、FindCount）都放在 Model 文件中实现。
4.  **数据转换：** 始终在 Logic 层进行数据转换，将底层的数据库 Model (`model.xxx`) 转换为上层的 API 类型 (`types.xxx`)，确保接口输出的稳定性。